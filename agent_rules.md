### 生成/升级该系统时必须满足的约束

一、输入与上下文约束（Context & Inputs）

1. 规则切片注入约束
   coding agent 每次生成/修改某个组件时，只允许加载与该组件类型、端口类型、交互模式匹配的一组规则（而非全量规则），以控制上下文规模，避免上下文过大导致生成质量下降。

2. 组件边界约束
   agent 的生成范围必须以“单组件”为基本单位；除非由编译失败或依赖修复计划显式要求，否则不得跨组件随意改动。

3. 依赖信息显式化约束
   agent 只能基于显式的组件关系描述（组件依赖、端口、交互模式）来理解上下游，不得依赖隐式推断或假设隐藏依赖存在。

二、接口与关系建模约束（Types & Relations）
4. 关系必须可描述约束
agent 生成的每个组件必须同时产出/更新其接口与关系描述信息，使组件提供与依赖的关系在系统中可被表达与追踪，而不是只生成代码。

5. 交互模式必须用统一抽象表达约束
   单向、双向、reactive、共享 bulletin board、message queue 等交互方式，必须落在系统支持的关系抽象里；agent 不得绕开抽象直接用“任意通信方式”实现隐式耦合。

6. 类型约束一致性约束
   组件接口的 type 变化必须被显式表达；如果变化导致不兼容，必须触发编译期失败或进入显式的升级路径，不允许通过运行期容错“默默吞掉不兼容”。

三、编译与失败处理约束（Build & Failure Semantics）
7. 编译期可检查约束
agent 交付的产物必须保证：接口与关系的约束可在编译阶段被检查（包括类型不匹配、关系不满足等），而不是把关键错误推迟到运行期。

8. 失败即信号约束
   当组件升级影响接口类型导致不兼容时，agent 不得通过“放宽类型/删约束/禁用检查”来让构建通过；编译失败是演化控制信号，必须保留。

9. 失败后的动作受控约束
   出现编译错误时，agent 的修复动作必须属于两类之一：

* 产出可供用户选择的修复方案（例如升级哪些组件/是否引入适配），或
* 执行自动升级/适配以恢复兼容
  但不得进行无边界的全局重构。

四、测试与质量门槛约束（Testing & Quality Gates）
10. 组件可单测约束
agent 生成的组件必须在隔离条件下可被独立测试；不得将关键逻辑散落到外部环境或强依赖不可控的共享状态，使组件无法单测。

11. 系统可集测约束
    agent 的生成不得破坏整体可测试性；组件组合后的系统必须仍可通过集成测试验证关键链路。

12. 测试驱动质量约束
    agent 必须以测试作为主要质量保障手段：生成/升级后必须补齐或更新相应测试，使“通过测试”成为可接受的判据，而不是依赖人工审查。

13. 自动化高频验证约束
    开发形态可以宏观上呈现瀑布式阶段，但每个阶段内部必须包含由 agent 执行的高频编译与测试循环，以持续保证质量收敛。

五、演化与自动升级约束（Evolution & Self-healing）
14. 升级必须可追踪约束
组件升级必须显式体现为接口类型与关系描述的版本变化，保证系统对演化过程可追踪、可回滚、可定位影响范围。

15. 自动升级必须保持整体可维护约束
    agent 在执行自动升级时必须遵守既定的关系抽象、类型约束与测试门槛，目标是让系统持续处于“良维护”状态，而不是短期跑通。

16. 局部质量收敛支撑整体可控约束
    agent 的生成策略应以“先保证单组件类型正确与测试通过”为优先前提，通过局部收敛来降低整体演化的不确定性。

六、安全与漏洞约束（Security & Vulnerability Awareness）
17. 漏洞信息纳入生成约束
agent 在生成与升级过程中应考虑依赖库的已知漏洞信息（如 CVE），避免引入或继续使用存在已知风险的依赖，从而提升软件质量。

18. 安全不降低约束强度
    若漏洞信息要求升级或替换依赖，agent 的处理必须同样受类型约束与测试约束限制；不得通过绕过检查来换取“短期可用”。

